---
layout: post
current: post
cover: assets/images/Outstanding-Set-of-Software-Engineers-Vectors-3.jpg
navigation: True
title: 데코레이터 패턴(Decorator Pattern) with Typescript
date: 2020-07-10 11:18:00
tags: [DesignPattern]
class: post-template
subclass: 'post tag-DesignPattern'
logo: assets/images/ghost.png
author: eatingcookieman
---

{% include designPattern-table-of-contents.html %}

## 카페나 한번 해볼까?

민수는 대학교 공부는 자신의 길이 아님을 깨닫고 무작정 사회로 뛰쳐 나왔습니다. 밤샘 과제를 하며 자신을 달래주던 커피가 생각난 민수는 카페를 열기로 결심합니다! 커피를 먹을 줄만 알았지 만들 줄은 몰랐던 민수는 간단하게 '에스프레소'와 
'아메리카노'만 만들기로 결심합니다.

## 커피 만들기

민수는 이전에 출석이나 나가던 객체지향 프로그래밍 수업이 떠올랐습니다. 수업을 듣지 않던 민수는 내용이 기억날 리가 없었지만 그래도 이거 하나는 기억하나봅니다.

> 객체지향 프로그래밍은 상속을 통해 재사용성을 높여준다

민수는 상속을 왜 하는지, 정말 상속이 재사용성을 높여주는 지는 몰랐지만 어찌됐든 저 문장이 꽤나 멋있어 보였기 때문에 다음과 같이 커피를 만들어보기로 합니다.

> 공통된 속성을 부모로 묶고 자식들은 그걸 상속해서 받으면 되겠지! 커피는 음료니까 `Beverage` 클래스를 만들고 `Espresso`와 `Americano`가 자식 클래스가 되면 되겠지?

따라서 민수는 다음과 같은 구조를 생각해봅니다. `cost()`는 각 음료가 가지는 가격을 반환하며 `getDescription()`는 음료의 이름 즉, `description`을 반환합니다.

{% gist korECM/b6e5cf09c06c973d5347bd2f77f24bc8 %}

모든 음료는 각자의 가격을 가져야 하므로 `cost()`를 추상 메소드로 정의했으며 `getDescription()`는 추상 클래스에서 미리 정의했습니다!

> 공통된 부분도 부모한테 넣어서 자식이 재정의 할 필요가 없네~ 이게 바로 객체지향 프로그래밍이지ㅎㅎ

민수는 자신감이 넘치는 상태로 `커피`와 `아메리카노`를 구현하기 시작했습니다.

|    종류    | 가격  |
| :--------: | :---: |
| 에스프레소 | 3000  |
| 아메리카노 | 4000  |


{% gist korECM/492d1abf925588be2f2b77f405f41d44 %}

그럼 다음과 같은 형태로 사용할 수 있습니다.

```typescript
let firstCoffee = new Americano();
console.log(`${firstCoffee.getDescription()} : ${firstCoffee.cost()}원`);
// 아메키라노~ : 4000원
```

## 더 많은 커피 만들기...?

공부는 안했지만 민수는 친구라도 많았기에 민수 카페는 입소문을 타게 되고 어찌어찌 성공하게 됩니다. 날이 더워져 아아족 손님들은 아이스 커피를 요구하게 되고 친절한 카페 사장님인 민수는 이를 반영하게 됩니다.

민수는 아이스 커피를 기존 클래스 이름에 `Ice`를 붙여 새로 만들기로 했고 얼음을 추가하는 만큼 가격도 500원 더 받기로 했습니다.

|    종류    | 가격  |
| :--------: | :---: |
| 에스프레소 | 3000  |
| 아메리카노 | 4000  |
|    추가    | 가격  |
|    얼음    |  500  |

{% gist korECM/57d93d4a43385ffc6d418cb7bc1025e8 %}

여전히 상속을 이용하고 자식 클래스를 만들어내고 있지만 민수는 슬슬 의문점이 들기 시작합니다.

> 내가 정말 객체지향 프로그래밍을 함으로써 재사용성을 얻고 있는 걸까?

커피를 먹지않은 사람들을 위해 민수는 그린티도 만들기 시작했습니다. 물론 얼음 넣어서도 팔고요!

|    종류    | 가격  |
| :--------: | :---: |
| 에스프레소 | 3000  |
| 아메리카노 | 4000  |
|   그린티   | 3500  |
|    추가    | 가격  |
|    얼음    |  500  |

{% gist korECM/1b29168c814d7c2f349dc8c658b15b27 %}

> 정말로 우린 재사용성을 얻고있는 걸까요..?

그래도 손님을 위해서 이정도 고생은 할 수 있다고 생각하던 민수는 얼음 값이 오른다는 소식을 듣게됩니다. 이대로라면 아이스 음료를 팔면 손해를 보기 때문에 어쩔 수 없이 얼음을 추가하면 `500`원이 아닌 `1000`원을 받기로 결정합니다.


|    종류    | 가격  |
| :--------: | :---: |
| 에스프레소 | 3000  |
| 아메리카노 | 4000  |
|   그린티   | 3500  |
|    추가    | 가격  |
|    얼음    | 1000  |

메뉴판을 고치고 난 민수는 모든 메뉴의 가격을 수정하기 위해 코드 하나하나를 수정해나가게 됩니다.


## 이대로 괜찮은 걸까요?

민수는 분명 재사용성을 얻기 위해서, 코드를 보다 쉽게 수정하기 위해 위와 같은 구조를 설계했었습니다. 그런데 카페를 확장해 나가면서 보다 코드를 유연하게 수정하고 재사용하고 있다는 생각이 들었나요? 

객체지향 프로그래밍 수업을 훌룡히 들은 학생이라면 다음과 같은 방법도 고려해 볼 수 있을 겁니다.

{% gist korECM/b1c97c5d52e321c372f19320b4f62fa7 %}

위와 같은 코드를 활용하면 이전 음료들처럼 클래스가 무식하게 늘어나지 않게 됩니다. 다만 여전히 문제가 없을까요? 아래와 같은 상황을 생각해봅시다.

* 첨가물의 가격이 바뀌면 여전히 전체 코드를 수정해야 합니다.
* 첨가물이 추가되면 부모 클래스에 메소드를 추가해야 하고 모든 음료의 `cost()` 또한 수정해야 합니다
  * 얼음처럼 모든 음료에 적용될 수 있는 첨가물이 새로 생기는 경우 모든 음료의 `cost()`를 수정해야 합니다
* 음료는 부모 클래스의 모든 메소드를 상속받게 됩니다. 이 과정에서 쓸데없는, 또는 추가되서는 안되는 메소드가 상속될 수 있습니다
  * 아이스티에 샷을 추가하거나 그린티에 휘핑을 올려먹는 사람이 있을 수도 있지만.. 일반적인 경우는 아닙니다
* 만약 우리 카페가 손님의 의견을 적극 반영하여 얼음 적게, 얼음 많이, 더블 샷 추가 등등을 받을 수 있다면 위 클래스로 손쉽게 구현이 가능할까요..? 각 상황마다 메소드를 추가해야 하지 않을까요?

## OCP(Open-closed Principle)

위 규칙 자체는 간단합니다!

> 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다

문장 자체는 매우 간단하지만 이 원칙이 어떻게 성립할 수 있는지는 쉽게 와닿지 않습니다.

다시 말하면, 우리의 기존 코드는 변경하지 않고 새로운 기능을 추가할 수 있는 경우가 바로 위 원칙이 성립하는 경우입니다. 우리 카페에 맞추어 생각해 보면 기존 코드는 건드리지 않고 기간 한정 상품으로 아메리카노만 아이스 옵션을 제공한다거나, 그린티, 아이스티는 제외하고 다른 커피 음료에만 샷 추가 옵션을 제공하는 것입니다.

> 그럼 모든 부분에 대해서 OCP를 지킬 수 있을까요?

아뇨 일반적으로 불가능합니다. 또한 그렇게까지 할 필요도 없고요. 우리가 객체지향 프로그래밍을 하는 이유는 기존 코드를 수정하지 않고 유연하고 확장성 있는 디자인을 하기 위해서입니다. 하지만 위 사례에서 봤듯이 그런 디자인을 하는건 그리 쉬운 일이 아니죠. 

> 그럼 어쩔 떄 OCP를 지켜가며 디자인 해나가야 하나요?

설계 단계에서 이 부분은 나중에 바뀔 수도 있을 것 같다(가격 등), 확장이 손쉬우면 좋을 것 같은 부분을 따로 뺴서 원칙을 적용하면 됩니다.

## 그래서 어떻게 하면 될까요?

우리는 데코레이터 패턴을 사용할 겁니다.

> 데코레이터 패턴에서는 객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다

데코레이터 패턴의 정의 자체는 다음과 같습니다만 솔직히 말로는 와닿지 않으므로 민수의 카페를 도와주면서 한번 살펴봅시다!

민수 카페에서 바뀔 수 있는 부분은 음료 자체, 그리고 첨가물의 종류이며 이를 통해 바뀌는 값은 바로 가격입니다. 더 나아가면 음료의 설명 또한 바뀔 수 있겠죠.

민수 카페는 커피의 원두, 그리고 우유, 모카, 아이스, 휘핑 첨가물을 제공한다고 합니다. 사용자가 커피를 주문하는 방식은 원두를 선택하고 사용자에 따라 첨가물을 정하게 될 겁니다. 즉, 커피 원두가 정해지고 나면 첨가물이 커피를 **꾸며주게** 됩니다.

즉, 다르게 말하면 첨가물이 우리의 커피를 `decorate` 해주는 것이겠죠. 첨가물 클래스를 `데코레이터`라고 해봅시다.

첨가물들이 어떤 원두로 만들어진 커피에 들어갈 지 알 수 없으니 각 첨가물 즉, 데코레이터는 `Beverage`를 인스턴수 변수에 저장하고 있어야 합니다. 바뀌는 부분 즉, `cost()`가 호출이 되면 데코레이터는 자신만의 어떤 행동을 추가하고 역할을 넘기게 됩니다. 말로는 잘 이해가 안되니 코드로 한번 살펴봅시다!

{% gist korECM/1f9c3cdcca1a5e299c66001be0a35ee2 %}

`Beverage` 클래스는 달라진 부분이 없습니다.

{% gist korECM/dcfe02f3eb590d220283419ce006f1d3 %}

`Americano` 또한 달라진 부분은 없습니다!

자 이제 첨가물 즉, `Decorator`를 구현해 봅시다. 모든 첨가물들은 `cost()` 메소드를 구현해야 하며(자신의 역할을 추가하기 위해서 즉, 가격을 더해주기 위해서) 음료 설명 또한 추가해주기 위해서 `getDescription()` 메소드 또한 추상 메소드로 선언해줄 것입니다. 즉, 데코레이터를 위한 추상 클래스를 먼저 만들고 이를 구현하는 방식으로 데코레이터를 만들어나갈 것입니다.

{% gist korECM/584f1b387b896b750fed6eae693ebd04 %}

뒤에서 데코레이터를 사용하는 모습을 보면 알 수 있겠지만 `Beverage` 객체가 들어갈 위치에 데코레이터가 들어갈 수 있어야 하므로 `Beverage`를 상속합니다. 또한 모든 첨가물들은 음료 설명에 자신을 추가하기 위해서 `getDescription()`를 새로 구현해야 하므로 추상 메소드로 선언을 했습니다.

간단하게 첨가물로 얼음부터 추가를 해봅시다! 얼음 가격은 여전히 500원이고 음료 설명 뒤에는 `, 아이스` 라는 문구를 붙이겠습니다.

{% gist korECM/eb90b48200303115fd44c443821ceb51 %}

왜 `Beverage`를 받아서 `beverage`로 저장하는지 감이 잡히시나요? `데코레이터`는 그저 동적으로 기능을 추가해주기 때문에 `getDescription()`, `cost()`를 호출하는 과정에서 자신의 기능을 추가하고 넘겨주게 됩니다. 

기능을 더 추가하기 전에 정상적으로 결과가 잘 나오는지 확인을 해보죠. 민수는 꼼꼼하거든요

{% gist korECM/e2f98d2896f86e42e6e3ac098c4e140c %}

```
아메리카노, 아이스는 3500원입니다~
아메리카노, 아이스, 아이스는 4000원입니다~
```

얼음을 많이 추가하는 경우에도 가격을 알아서 잘 계산하는 것을 볼 수 있습니다! 데코레이터 방식이 어떤 방식인지 감이 잘 오시나요?

민수 카페의 성공을 위해 카페 라떼도 추가해봅시다!

{% gist korECM/e33a6779e846130a7cbb0132065590e0 %}

아메리카노와 형식은 똑같습니다. 테스트 해보기 전에 휘핑도 추가해보죠.

{% gist korECM/84682db5ef9b51e79dd5e39c3655370a %}

위와 같이 클래스를 구성하면 아래처럼 손님의 요구에 맞게 동적으로 다양한 메뉴를 만들 수 있습니다.

{% gist korECM/73359a7638995f24663eb9183e66031c %}

```
아메리카노는 3000원입니다~
카페라떼, 아이스, 휘핑, 휘핑는 7000원입니다~
```

어떤 느낌인지 감이 오시나요? 

## 그래서 결론은?

`데코레이터 패턴`이라는 것을 이용해서 민수의 카페 문제를 해결해보았습니다. 우리가 구현한 패턴이 어떤 유용한 점이 있을지 잘 생각해보세요.

* 만약 새로운 커피, 예를 들어 디카페인 원두가 추가된다면 우리의 코드 전체를 고쳐야할까요?
  * 그저 `Beverage`를 상속하는 `DecaffeinCoffe`를 추가하면 됩니다
* 만약 첨가물의 가격이 변경되면 전체 코드르 고쳐야하나요?
  * 만약 얼음 값이 1000원이 되었다면 그저 `Ice` 하나만 수정하면 됩니다!
* 데코레이터가 자신을 구성하는 요소를 확인하고 그에 따른 행동을 정할 수 있나요? 예를 들어 아메리카노는 아이스 옵션이 500원인데 디카페인 커피는 특별 행사로 아이스 옵션을 300원에 제공하게 만들 수 있나요?
  * 데코레이터는 그저 인터페이스를 받아서 자신의 행동을 추가하기 때문에 자신이 받은 요소가 아메리카노인지, 디카페인 커피인지 알 수가 없습니다. 만약 그런 경우를 고려해야 한다면 데코레이터 패턴을 사용하는 것이 맞는지 다시 생각해 볼 필요가 있습니다
* 만약 데코레이터 순서가 중요한 경우에는 어떻게 해야하나요?
  * 만약 커피가 아니라 음식이라 데코레이터가 작용하는 순서가 중요하다면 위 패턴에서는 이를 방지하기가 힘듭니다. 또한 관리해야 할 객체가 많다면 코딩하는 과정에서 오류를 만날 수도 있고요. 하지만 일반적으로 데코레이터 패턴은 `팩토리 패턴`이나 `빌더 패턴`과 함께 사용해 추상화하기 때문에 크게 걱정할 문제는 아닙니다!

